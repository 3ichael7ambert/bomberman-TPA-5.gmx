<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>special_msk</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>real_msk</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// -- AI CONTROLLER --
// automaticly sets controlling values for the input variables from input_get object
alarm[0]=2;
// set the timers
alarm[1]=15;
alarm[2]=random(10);
// set the ai off for a while
aimode=ai_off;
aiwait=0;
// create a path for pathfinding
my_path=path_add();
// other
escapex=-1;
escapey=-1;
// antibugs
prevx=-1;
prevy=-1;
stayed=0;</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// delete the path for pathfinding
path_delete(my_path);</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if aimode=ai_off exit;
if !instance_exists(obj) exit;
if obj.rui!=0 exit;

// try to attack the enemy in other ways
if aimode=ai_playerfollow
  {
  // if has a throw powerup
  if obj.bmbtoss=1
    {
    // if in same row with enemy
    if round(obj.x/16)*16=round(aitarget.x/16)*16
    or round(obj.y/16)*16=round(aitarget.y/16)*16
      {
      // if there is a way to escape and is close enough
      if ai_anyescapeaway(round(obj.x/16),round(obj.y/16),1)
      and point_distance(obj.x,obj.y,aitarget.x,aitarget.y)&lt;60
        {
        // throw a bomb
        aimode=ai_toss;
        aiwait=3;
        global.bmb_hold[player,4]=2;
        }
      }
    }
  }
alarm[2]=5;</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// ai will update it's escape track every half of second
if aimode=ai_bombescape
  {
  if instance_place(escapex*16,escapey*16,notsafe_place)
  or instance_place(escapex*16,escapey*16,bomb)
  aimode=ai_playerfollow;
  }
if aimode=ai_randomwalk aimode=ai_playerfollow;
alarm[1]=30;</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// remove the controller if there is no proper obj set
if !instance_exists(obj) { instance_destroy(); exit; }
// set position to the bot's real position
x=obj.x+8;
y=obj.y+8;
// set a player as ai
input_get.ai[player]=1;
// set the ai mode
aimode=ai_playerfollow;
// set the object target
do {
    aitarget=choose(bomberman1,bomberman2,bomberman3,bomberman4,
    bomberman5,bomberman6,bomberman7,bomberman8,bomberman9,
    bomberman10,bomberman11,bomberman12,bomberman13,
    bomberman14,bomberman15,bomberman16);
}until(aitarget!=obj and instance_exists(aitarget))
// set the position target
aitargetx=aitarget.x;
aitargety=aitarget.y;</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// if ai is off, stop
if aimode=ai_off exit;
if !instance_exists(obj) exit;

if round(prevx/16)=round(obj.x/16) and round(prevy/16)=round(obj.y/16)
  {
  stayed+=1;
  }
  else
  {
  stayed=0;
  }
if stayed&gt;30
  {
  x=obj.x+8;
  y=obj.y+8;
  stayed=0;
  }</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// if ai is off, stop
if aimode=ai_off exit;
if !instance_exists(obj) exit;

// count the previous position (for debug purposes)
prevx=obj.x;
prevy=obj.y;

// debug things, don't uncomment
/*if keyboard_check(vk_numpad1) and player=0 visible=1;
if keyboard_check(vk_numpad2) and player=1 visible=1;
if keyboard_check(vk_numpad3) and player=2 visible=1;
if keyboard_check(vk_numpad4) and player=3 visible=1;
if keyboard_check(vk_numpad5) and player=4 visible=1;
if keyboard_check(vk_numpad6) and player=5 visible=1;
if keyboard_check(vk_numpad7) and player=6 visible=1;
if keyboard_check(vk_numpad8) and player=7 visible=1;
if keyboard_check(vk_numpad0) visible=0;*/</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// before a move, reset all controls.
control_reset(player);

// if ai is off, stop
if aimode=ai_off exit;

// if bot is dead, stop.
if !instance_exists(obj) exit;
if !instance_exists(aitarget)
  {
  if instance_number(bomberman_parent)=1
    {
    instance_destroy();
    exit;
    }
  do {
    aitarget=choose(bomberman1,bomberman2,bomberman3,bomberman4,
    bomberman5,bomberman6,bomberman7,bomberman8,bomberman9,
    bomberman10,bomberman11,bomberman12,bomberman13,
    bomberman14,bomberman15,bomberman16);
    }until(aitarget!=obj and instance_exists(aitarget))
  }
// if there are more bombermen on battlefield than 1 and the distance to the nearest enemy is smaller
// than 120, then change the target to him.
if instance_number(bomberman_parent)&gt;1
  {
  with(obj)
  if distance_to_object(instance_nearest(x,y,bomberman_parent))&lt;120
    {
    aitarget=instance_nearest(x,y,bomberman_parent);
    }
  }

// if ai is in sleep mode, then quit
if aiwait&gt;0
  {
  aiwait-=1;
  exit;
  }
  
// attack modes are checked before because they shouldn't be stopped by escaping.
if aimode=ai_toss
  {
  global.bmb_hold[player,4]=1;
  aimode=ai_toss2;
  aiwait=2;
  exit;
  }
if aimode=ai_toss2
  {
  global.bmb_hold[player,4]=3;
  aimode=ai_playerfollow;
  aiwait=2;
  exit;
  }
  
// check if the place bomberman is standing on is safe and is not already escaping
if aimode!=ai_bombescape
{
if place_meeting(round(obj.x/16)*16,round(obj.y/16)*16,notsafe_place) or place_meeting(round(obj.x/16)*16,round(obj.y/16)*16,bomb)
  {
  // if it is, look for a way to escape
  ai_anyescapeaway(round(obj.x/16),round(obj.y/16));
  // and set the proper mode
  aimode=ai_bombescape;
  // reset position
  x=obj.x+8;
  y=obj.y+8;
  }
}

// depending on the mode, set the controls

// if ai has to walk randomly...
if aimode=ai_randomwalk
  {
  // set the path from the marker to the enemy
  mp_grid_path(global.mpgrid,my_path,x,y,aitargetx,aitargety,0);
  path_set_kind(my_path,0);
  path_set_precision(my_path,0);
  // run thru the path
  path_start(my_path,get_speed(obj.bmbspeed),0,0);
  // stop the marker if it's too far away from the bot it's controling
  if distance_to_object(obj)&gt;10
    path_speed=0;
    else
  if distance_to_object(obj)&gt;5
    path_speed=get_speed(obj.bmbspeed)/2;
    else
    path_speed=get_speed(obj.bmbspeed);
  // snap to the grid for more precision
  move_snap(get_speed(obj.bmbspeed),get_speed(obj.bmbspeed));
  // round the target for bot to follow
  aitargetx=round((x-8)/16)*16;
  aitargety=round((y-8)/16)*16;
  // if the bot is near enough to the goal change the ai mode
  if round(obj.x/16)*16=round(aitarget.x/16)*16 or round(obj.y/16)*16=round(aitarget.y/16)*16
    {
    aimode=ai_playerfollow;
    }
  // and make him walk
  ai_follow(1,1);
  }
  else
// if ai has to get a powerup...
if aimode=ai_powerupget
  {
  // set the path from the marker to the powerup
    ass=instance_nearest(obj.x+8,obj.y+8,item_obj);
  if !instance_exists(ass)
    {
    // ...then change the mode
    x=obj.x+8;
    y=obj.y+8;
    aimode=ai_playerfollow;
    }
    else
    {
  if point_distance(obj.x,obj.y,ass.x,ass.y)&gt;90
    aimode=ai_playerfollow;
  mp_grid_path(global.mpgrid,my_path,x,y,ass.x+8,ass.y+8,0);
  path_set_kind(my_path,0);
  path_set_precision(my_path,0);
  // run thru the path
  path_start(my_path,get_speed(obj.bmbspeed),0,0);
  // stop the marker if it's too far away from the bot it's controling
  if distance_to_object(obj)&gt;10
    path_speed=0;
    else
  if distance_to_object(obj)&gt;5
    path_speed=get_speed(obj.bmbspeed)/2;
    else
    path_speed=get_speed(obj.bmbspeed);
  // snap to the grid for more precision
  move_snap(get_speed(obj.bmbspeed),get_speed(obj.bmbspeed));
  // round the target for bot to follow
  aitargetx=round((x-8)/16)*16;
  aitargety=round((y-8)/16)*16;
  // and make him walk
  ai_follow(1,1);
  }
  }
// if ai has to follow a player...
if aimode=ai_playerfollow
  {
  // set the path from the marker to the enemy
  mp_grid_path(global.mpgrid,my_path,x,y,aitarget.x+8,aitarget.y+8,0);
  path_set_kind(my_path,0);
  path_set_precision(my_path,0);
  // if there are powerups on map
  if instance_number(item_obj)&gt;0
    {
    ass=instance_nearest(obj.x+8,obj.y+8,item_obj);
    // and if hero is near powerup, try to get it
    if point_distance(obj.x,obj.y,ass.x,ass.y)&lt;=90
      aimode=ai_powerupget;
    }
  // run thru the path
  path_start(my_path,get_speed(obj.bmbspeed),0,0);
  // stop the marker if it's too far away from the bot it's controling
  if distance_to_object(obj)&gt;10
    path_speed=0;
    else
  if distance_to_object(obj)&gt;5
    path_speed=get_speed(obj.bmbspeed)/2;
    else
    path_speed=get_speed(obj.bmbspeed);
  // snap to the grid for more precision
  move_snap(get_speed(obj.bmbspeed),get_speed(obj.bmbspeed));
  // round the target for bot to follow
  aitargetx=round((x-8)/16)*16;
  aitargety=round((y-8)/16)*16;
  // if the bot is near enough to the enemy and is in the same row, attack
  if round(obj.x/16)*16=round(aitarget.x/16)*16 or round(obj.y/16)*16=round(aitarget.y/16)*16
    {
    with(obj)
      {
      if distance_to_object(other.aitarget)&lt;(bmbfire-1)*16
        {
        global.bmb_hold[other.player,4]=2;
        aiwait=3;
        }
      }
    }
  // and make him walk
  ai_follow(1,1);
  }
  else
// if ai has to escape from the bomb blast...
if aimode=ai_bombescape
  {
  // do the extacly same things but the target is the safe place
  mp_grid_path(global.mpprecisegrid,my_path,x,y,escapex*16+8,escapey*16+8,0);
  path_set_kind(my_path,0);
  path_set_precision(my_path,0);
  // if escape option, change mode
  if escapex=-1 and escapey=-1
    {
    aimode=ai_playerfollow;
    x=obj.x+8;
    y=obj.y+8;
    }
  path_start(my_path,get_speed(obj.bmbspeed),0,0);
  if distance_to_object(obj)&gt;10
    path_speed=0;
    else
  if distance_to_object(obj)&gt;5
    path_speed=get_speed(obj.bmbspeed)/2;
    else
    path_speed=get_speed(obj.bmbspeed);
  move_snap(get_speed(obj.bmbspeed),get_speed(obj.bmbspeed));
  aitargetx=round((x-8)/16)*16;
  aitargety=round((y-8)/16)*16;
  // the second difference is that bomberman shouldn't bomb anything in the way
  // and can step in the bomb blast marker (because he would just stop and wait
  // for the death - the game wouldn't be fun then)
  ai_follow(0,0);
  if round(obj.x/16)=escapex and round(obj.y/16)=escapey
    {
    aimode=ai_playerfollow;
    }
  }
if instance_place(round((x-8)/16)*16,round((y-8)/16)*16,wall)
  {
  x=xprevious;
  y=yprevious;
  }</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// debug things, don't uncomment
/*for (i=0; i&lt;path_get_number(my_path); i+=1)
  {
  draw_set_color(c_white);
  draw_line(path_get_point_x(my_path,i),path_get_point_y(my_path,i),
  path_get_point_x(my_path,i+1),path_get_point_y(my_path,i+1));
  }*/
/*draw_sprite(sprite_index,0,x-8,y-8);
draw_sprite_ext(sprite_index,0,escapex*16,escapey*16,1,1,0,c_blue,0.8);
draw_set_color(c_white);
draw_path(my_path,x,y,0);
draw_text(view_xview,view_yview,"x:"+string(round(prevx/16))+",x:"+string(round(obj.x/16)));
*///draw_text(view_xview,view_yview,"x:"+string(aitargetx)+",y:"+string(aitargety));</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="17">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>aimode=ai_follow;</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
